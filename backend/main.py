import os
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from dotenv import load_dotenv
from supabase import create_client, Client
import requests
from typing import Optional

# Load environment variables
load_dotenv()

app = FastAPI(title="AI Meeting Assistant Backend")

# Supabase configuration
SUPABASE_URL = os.getenv("SUPABASE_URL")
SUPABASE_SERVICE_ROLE_KEY = os.getenv("SUPABASE_SERVICE_ROLE_KEY")

if not SUPABASE_URL or not SUPABASE_SERVICE_ROLE_KEY:
    raise RuntimeError(
        "Missing required environment variables. "
        "Please set SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY in backend/.env"
    )

# Initialize Supabase client with service role key (bypasses RLS)
supabase: Client = create_client(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)

# Expo Push Notification endpoint
EXPO_PUSH_URL = "https://exp.host/--/api/v2/push/send"


class ProcessMeetingRequest(BaseModel):
    audio_url: str
    meeting_id: str
    push_token: Optional[str] = None


@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"ok": True}


@app.post("/process-meeting")
async def process_meeting(request: ProcessMeetingRequest):
    """
    Process meeting audio: mock transcription, summarization, and send push notification.

    Steps:
    1. Mock "transcribe" the audio (placeholder text)
    2. Mock "summarize" the transcript (placeholder text)
    3. Update the meeting record in Supabase with transcript and summary
    4. Send Expo push notification to the user's device
    """
    try:
        meeting_id = request.meeting_id
        audio_url = request.audio_url
        push_token = request.push_token

        print(f"Processing meeting {meeting_id}")
        print(f"Audio URL: {audio_url}")
        print(f"Push token: {push_token}")

        # Step 1 & 2: Mock transcription and summarization
        # In a real implementation, you would:
        # - Download the audio file from audio_url
        # - Use a speech-to-text API (Whisper, Google, etc.)
        # - Use an LLM to generate a summary

        mock_transcript = """[Mock Transcript]

This is a placeholder transcript of the meeting. In a production implementation,
this would contain the actual transcribed text from the audio recording using
a speech-to-text service like OpenAI Whisper, Google Speech-to-Text, or similar.

The transcript would capture all spoken content from the meeting, including:
- Discussion topics
- Action items
- Decisions made
- Questions asked
- Participant contributions

This mock transcript demonstrates the structure and format of what would be
generated by the transcription service."""

        mock_summary = """# Meeting Summary

**Key Discussion Points:**
- Initial project planning and scope definition
- Resource allocation and timeline review
- Identified potential blockers and mitigation strategies

**Action Items:**
- Follow up on budget approval (Owner: TBD, Due: Next week)
- Schedule follow-up meeting with stakeholders
- Prepare detailed technical specifications

**Decisions Made:**
- Approved overall project direction
- Agreed on initial timeline and milestones

This is a mock summary. In production, this would be generated by an LLM
analyzing the transcript to extract key insights, action items, and decisions."""

        # Step 3: Update meeting record in database
        print(f"Updating meeting {meeting_id} in database...")

        update_result = supabase.table("meetings").update({
            "status": "ready",
            "transcript": mock_transcript,
            "summary": mock_summary,
        }).eq("id", meeting_id).execute()

        if not update_result.data:
            raise HTTPException(
                status_code=500,
                detail="Failed to update meeting record in database"
            )

        print(f"Meeting {meeting_id} updated successfully")

        # Step 4: Send Expo push notification
        if push_token:
            print(f"Sending push notification to {push_token}...")

            notification_payload = {
                "to": push_token,
                "sound": "default",
                "title": "Transcript Ready",
                "body": "Tap to view your meeting notes",
                "data": {
                    "meetingId": meeting_id
                },
                "channelId": "meeting-ready",
            }

            try:
                push_response = requests.post(
                    EXPO_PUSH_URL,
                    json=notification_payload,
                    headers={
                        "Accept": "application/json",
                        "Content-Type": "application/json",
                    },
                    timeout=10,
                )

                push_response.raise_for_status()
                push_result = push_response.json()
                print(f"Push notification sent: {push_result}")

            except Exception as push_error:
                print(f"Failed to send push notification: {push_error}")
                # Don't fail the entire request if push notification fails
        else:
            print("No push token provided, skipping notification")

        return {
            "ok": True,
            "meeting_id": meeting_id,
            "status": "ready",
            "message": "Meeting processed successfully",
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Error processing meeting: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to process meeting: {str(e)}"
        )
